<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>跨青年 Trans Youth 状态页</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="icon" href="https://transyouth.xyz/favicon.ico">
</head>
<body class="bg-gray-50 text-gray-900">
  <main class="max-w-7xl mx-auto p-6">
    <header class="mb-6">
      <h1 class="text-2xl font-semibold">跨青年 Trans Youth 状态页</h1>
      <p class="text-sm text-gray-600">最近 24 小时状态概览 · 数据每 5 分钟更新</p>
    </header>

    <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
      <div class="text-sm text-gray-600">数据来源：GitHub Actions 探活 · 最后更新时间：<span id="updated">—</span></div>
      <div class="text-sm text-gray-600">显示节点数：<span id="count">0</span></div>
    </div>

    <section id="grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 gap-4"></section>

    <footer class="mt-6 text-sm text-gray-500">页面自动刷新：每 30 秒</footer>
  </main>

  <aside id="detailPanel" class="fixed inset-y-0 right-0 w-full md:w-1/3 lg:w-1/4 bg-white shadow-xl transform translate-x-full transition-transform duration-200 z-50">
    <div class="p-4 border-b flex items-start justify-between">
      <div>
        <div id="detailName" class="font-semibold text-lg"></div>
        <div id="detailUrl" class="text-xs text-gray-500"></div>
      </div>
      <button id="closeDetail" class="text-gray-500 hover:text-gray-800" aria-label="关闭">✕</button>
    </div>

    <div class="p-4 overflow-y-auto" style="max-height: calc(100vh - 88px);">
      <div class="mb-4">
        <div class="text-sm text-gray-600">最新状态： <span id="detailLatest" class="font-medium"></span></div>
        <div class="text-sm text-gray-600">可用率： <span id="detailUptime" class="font-medium"></span>%</div>
        <div class="text-sm text-gray-600">平均响应： <span id="detailRtt" class="font-medium"></span> ms</div>
      </div>

      <div>
        <h3 class="text-sm font-medium mb-2">最近检查（时间顺序：最新在上）</h3>
        <div id="historyList" class="space-y-2 text-xs text-gray-700"></div>
      </div>
    </div>
  </aside>

  <div id="overlay" class="hidden fixed inset-0 bg-black/40 z-40"></div>

  <script>
    // --- util helpers ---
    const pct = arr => {
      if (!arr || arr.length === 0) return 0
      const ok = arr.filter(x => x.status === 'ok').length
      return Math.round((ok / arr.length) * 100)
    }
    const avgRtt = arr => {
      if (!arr) return null
      const vals = arr.map(x => x.rtt).filter(Boolean)
      if (!vals.length) return null
      return Math.round(vals.reduce((a,b)=>a+b,0)/vals.length)
    }

    function statusBadgeClass(st) {
      if (st === 'ok') return 'bg-green-50 text-green-800 ring-green-200'
      if (st === 'degraded') return 'bg-yellow-50 text-yellow-800 ring-yellow-200'
      if (st === 'down') return 'bg-red-50 text-red-800 ring-red-200'
      return 'bg-gray-50 text-gray-700 ring-gray-200'
    }

    // --- sparkline generator ---
    // history: array of entries (oldest -> newest)
    // width,height in px; maxPoints controls number of samples (we pick last maxPoints)
    function makeSparklineSvg(history = [], width = 140, height = 28, maxPoints = 20, color = '#34d399', fallback = '#cbd5e1') {
      if (!history || history.length === 0) {
        // empty placeholder: small gray line
        return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <rect width="${width}" height="${height}" fill="none"></rect>
          <polyline points="0 ${height/2} ${width} ${height/2}" stroke="${fallback}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none" stroke-dasharray="3 3"></polyline>
        </svg>`
      }

      // take last maxPoints entries
      const points = history.slice(-maxPoints).map(h => h.rtt != null ? h.rtt : null)
      // compute x spacing
      const n = points.length
      const xs = []
      const step = n > 1 ? (width / (n - 1)) : width
      for (let i=0;i<n;i++) xs.push(i * step)

      // determine y scale from rtt values (ignore nulls)
      const vals = points.filter(v => v != null)
      let min = vals.length ? Math.min(...vals) : 0
      let max = vals.length ? Math.max(...vals) : 1
      // small padding
      if (min === max) {
        // if all equal, create a small range so line not flat on edge
        min = min - 1
        max = max + 1
      }
      const range = max - min

      // map to y coordinate (0 top -> height bottom)
      const coords = points.map((v, i) => {
        const x = xs[i] || 0
        if (v == null) return null
        const y = height - ((v - min) / range) * (height - 4) - 2 // 2px padding top/bottom
        return { x: Math.round(x), y: Math.round(y) }
      })

      // build path skipping nulls (we draw continuous segments where data exists)
      let pathD = ''
      let polylinePoints = []
      let segs = [] // store segments as arrays of points
      for (let i=0;i<coords.length;i++){
        const p = coords[i]
        if (p) {
          polylinePoints.push(`${p.x},${p.y}`)
        } else {
          if (polylinePoints.length) { segs.push(polylinePoints); polylinePoints = [] }
        }
      }
      if (polylinePoints.length) segs.push(polylinePoints)

      // color for line (use provided color)
      const stroke = color
      const strokeFallback = fallback

      // build svg: draw light bg polyline for baseline, then colored segments
      let svg = `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">`
      // background grid line (optional subtle center)
      svg += `<line x1="0" y1="${height/2}" x2="${width}" y2="${height/2}" stroke="#eef2f7" stroke-width="1"></line>`

      // draw segments
      if (segs.length === 0) {
        svg += `<polyline points="0 ${height/2} ${width} ${height/2}" stroke="${strokeFallback}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" fill="none" stroke-dasharray="3 3"></polyline>`
      } else {
        // draw a faint area under curve for visual
        // compute overall min/max y for area baseline
        // draw each segment
        segs.forEach((seg, idx) => {
          svg += `<polyline points="${seg.join(' ')}" stroke="${stroke}" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" fill="none" opacity="1"></polyline>`
          // small circle at last point of last segment to emphasize latest
          if (idx === segs.length - 1) {
            const last = seg[seg.length - 1].split(',')
            svg += `<circle cx="${last[0]}" cy="${last[1]}" r="1.6" fill="${stroke}"></circle>`
          }
        })
      }

      svg += `</svg>`
      return svg
    }

    // escape helper
    function escapeHtml(str) {
      if (!str) return ''
      return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
    }

    // render grid
    async function renderGrid(data) {
      const grid = document.getElementById('grid')
      const updatedEl = document.getElementById('updated')
      const countEl = document.getElementById('count')
      updatedEl.textContent = data.updatedAt ? new Date(data.updatedAt).toLocaleString() : '—'
      const services = data.services || []
      countEl.textContent = services.length

      grid.innerHTML = services.map(s => {
        const history = s.history || []
        const uptime = pct(history)
        const rtt = avgRtt(history)
        const latest = history[history.length - 1] || {}
        const badge = statusBadgeClass(latest.status)

        // choose sparkline color based on status
        const sparkColor = latest.status === 'ok' ? '#34d399' : (latest.status === 'degraded' ? '#f59e0b' : (latest.status === 'down' ? '#ef4444' : '#94a3b8'))
        const svg = makeSparklineSvg(history, 140, 28, 20, sparkColor, '#e2e8f0')

        return `
          <button data-id="${s.id}" class="group text-left p-3 bg-white rounded-lg shadow-sm border hover:shadow-md focus:shadow-md transition-colors flex flex-col gap-3"
                  aria-controls="detailPanel" aria-expanded="false">
            <div class="flex items-start justify-between gap-3">
              <div class="flex-1 min-w-0">
                <div class="flex items-center gap-2">
                  <div class="text-sm font-medium truncate">${escapeHtml(s.name)}</div>
                  <div class="text-xs ${badge} px-2 py-0.5 rounded-full ring-1">${(latest.status||'unknown').toUpperCase()}</div>
                </div>
                <div class="text-xs text-gray-500 truncate mt-1">${escapeHtml(s.url)}</div>
              </div>
              <div class="text-right ml-2">
                <div class="text-sm font-semibold">${uptime}%</div>
                <div class="text-xs text-gray-500">${rtt ? rtt + ' ms' : '—'}</div>
              </div>
            </div>

            <div class="mt-1">
              <div class="w-full h-7">${svg}</div>
            </div>

            <div class="mt-auto text-xs text-gray-400">最近 ${history.length} 次</div>
          </button>
        `
      }).join('')

      // attach click handlers
      grid.querySelectorAll('button[data-id]').forEach(btn => {
        btn.addEventListener('click', () => openDetail(btn.getAttribute('data-id'), data))
      })
    }

    // detail panel open/close
    function openDetail(id, data) {
      const svc = (data.services || []).find(s => s.id === id)
      if (!svc) return
      const panel = document.getElementById('detailPanel')
      const overlay = document.getElementById('overlay')

      document.getElementById('detailName').textContent = svc.name
      document.getElementById('detailUrl').textContent = svc.url

      const history = (svc.history || []).slice().reverse()
      document.getElementById('detailLatest').textContent = history[0] ? history[0].status.toUpperCase() : '—'
      document.getElementById('detailUptime').textContent = pct(svc.history || [])
      document.getElementById('detailRtt').textContent = avgRtt(svc.history || []) || '—'

      const list = document.getElementById('historyList')
      list.innerHTML = history.map(h => {
        const c = h.status === 'ok' ? 'text-green-700' : (h.status === 'degraded' ? 'text-yellow-700' : 'text-red-700')
        const http = h.http || '—'
        const rtt = h.rtt ? h.rtt + ' ms' : '—'
        return `<div class="p-2 border rounded bg-gray-50">
          <div class="flex items-center justify-between gap-2">
            <div class="text-xs ${c} font-semibold">${(h.status||'unknown').toUpperCase()}</div>
            <div class="text-xs text-gray-500">${new Date(h.ts).toLocaleString()}</div>
          </div>
          <div class="mt-1 text-xs text-gray-600">HTTP: ${http} · 延迟: ${rtt} · ${escapeHtml(h.note || '')}</div>
        </div>`
      }).join('')

      panel.classList.remove('translate-x-full')
      overlay.classList.remove('hidden')
      document.getElementById('closeDetail').onclick = closeDetail
      overlay.onclick = closeDetail
    }

    function closeDetail() {
      const panel = document.getElementById('detailPanel')
      const overlay = document.getElementById('overlay')
      panel.classList.add('translate-x-full')
      overlay.classList.add('hidden')
    }

    // fetch status safely
    async function fetchStatus(url = 'status.json') {
      try {
        const res = await fetch(url, { cache: 'no-store' })
        if (!res.ok) throw new Error('HTTP ' + res.status)
        const data = await res.json()
        return data
      } catch (err) {
        console.warn('fetchStatus error', err)
        return { updatedAt: null, services: [] }
      }
    }

    let lastData = { updatedAt: null, services: [] }
    async function refresh() {
      const data = await fetchStatus('status.json')
      lastData = data
      await renderGrid(data)
      document.getElementById('updated').textContent = data.updatedAt ? new Date(data.updatedAt).toLocaleString() : '—'
    }

    window.addEventListener('keydown', e => { if (e.key === 'Escape') closeDetail() })
    refresh()
    setInterval(refresh, 30 * 1000)
  </script>
</body>
</html>
